package main

import "fmt"

// 闭包
// 是一种特殊的结构，违反了程序正常的生命周期
// 合法的使用  程序允许的一种特殊结构，变量作用域升级了
// 防止变量冲突  全局变量污染

/*
闭包结构:
一个外层函数中，有内层函数，该内层函数中，会操作外层函数的局部变量并且该外层函数的返回值就是这个内层函数。

在闭包结构中：局部变量的生命周期就会发生改变，
正常的局部变量会随着函数的调用而创建，随着函数的结束而销毁
但是闭包结构中的外层函数的局部变量并不会随着外层函数的结束而销毁，因为内层函数还在继续使用.

// 由于垃圾回收期不会将闭包中的变量销毁，可能会造成内存泄漏。
*/
// 你的代码变量和你同事的变量冲突了，解决。 i 新建一个变量。 第三方库中的代码都是闭包结构实现的导出。
func main() {

	r1 := increment()
	fmt.Println(r1) //返回的是一个 increment() 内存函数，还没执行
	//执行 内层函数
	v1 := r1()
	fmt.Println(v1)
	v2 := r1()
	fmt.Println(v2)
	fmt.Println(r1())
	fmt.Println(r1())
	fmt.Println(r1())

	fmt.Println("=======================")
	//r2和r1指向同一个地址
	r2 := increment()
	v3 := r2()

	fmt.Println(v3)
	fmt.Println(r1())
	fmt.Println(r2())
	//	这里的i并没有随着 第二次创建就被销毁 归0 而是在内层函数继续调用

}

// 自增函数
func increment() func() int { //外层函数
	//	定义局部变量
	i := 0
	fun := func() int {
		i++
		return i
	}
	return fun
}
